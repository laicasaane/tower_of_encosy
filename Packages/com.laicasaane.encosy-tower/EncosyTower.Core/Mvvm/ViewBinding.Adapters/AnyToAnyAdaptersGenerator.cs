#if UNITY_EDITOR && ANNULUS_CODEGEN && ENCOSY_MVVM_ADAPTERS_GENERATOR

using System;
using EncosyTower.CodeGen;
using UnityCodeGen;

namespace EncosyTower.Editor.Mvvm.Unions.Converters
{
    internal abstract class AnyToAnyAdaptersGenerator : ICodeGenerator
    {
        private static readonly string[] s_unionTypes = new string[] {
            "byte",
            "sbyte",
            "char",
            "double",
            "float",
            "int",
            "uint",
            "long",
            "ulong",
            "short",
            "ushort",
        };

        private static readonly string[] s_unionTypeNames = new string[] {
            "Byte",
            "SByte",
            "Char",
            "Double",
            "Float",
            "Int",
            "UInt",
            "Long",
            "ULong",
            "Short",
            "UShort",
        };

        protected abstract string ToType { get; }

        protected abstract string ToTypeName { get; }

        protected abstract string ReturnStatement { get; }

        protected abstract string FileName { get; }

        protected virtual string ToTypeNameLabel => null;

        protected virtual int Order => 0;

        public void Execute(GeneratorContext context)
        {
            if (CodeGenAPI.TryGetOutputFolderPath(nameof(AnyToAnyAdaptersGenerator), out var outputPath) == false)
            {
                context.OverrideFolderPath("Assets");
                return;
            }

            var p = Printer.DefaultLarge;
            p.PrintAutoGeneratedBlock(GetType().Name);
            p.PrintEndLine();
            p.PrintLine(@"#pragma warning disable

using System;
using EncosyTower.Annotations;
using EncosyTower.Unions;
");

            p.PrintLine("namespace EncosyTower.Mvvm.ViewBinding.Adapters");
            p.OpenScope();
            {
                var unionTypes = s_unionTypes.AsSpan();
                var unionTypeNames = s_unionTypeNames.AsSpan();
                var toType = ToType;
                var toTypeName = ToTypeName;
                var toTypeNameLabel = ToTypeNameLabel ?? toTypeName;
                var order = Order.ToString();
                var returnStatement = ReturnStatement;

                for (var i = 0; i < unionTypes.Length; i++)
                {
                    var type = unionTypes[i];
                    var typeName = unionTypeNames[i];

                    p.PrintLine("[Serializable]");
                    p.PrintBeginLine("[Label(\"").Print(typeName).Print(" â‡’ ")
                        .Print(toTypeNameLabel).PrintEndLine("\", \"Default\")]");
                    p.PrintBeginLine("[Adapter(sourceType: typeof(").Print(type)
                        .Print("), destType: typeof(").Print(toType)
                        .Print("), order: ").Print(order).PrintEndLine(")]");
                    p.PrintBeginLine("public sealed class ").Print(typeName)
                        .Print("To").Print(toTypeName)
                        .PrintEndLine("Adapter : IAdapter");
                    p.OpenScope();
                    {
                        p.PrintLine("public Union Convert(in Union union)");
                        p.OpenScope();
                        {
                            p.PrintBeginLine("if (union.TryGetValue(out ").Print(type).PrintEndLine(" result))");
                            p.OpenScope();
                            {
                                p.PrintBeginLine("return ").Print(returnStatement).PrintEndLine(";");
                            }
                            p.CloseScope();
                            p.PrintEndLine();

                            p.PrintLine("return union;");
                        }
                        p.CloseScope();
                    }
                    p.CloseScope();
                    p.PrintEndLine();
                }
            }
            p.CloseScope();
            p.PrintEndLine();

            context.OverrideFolderPath(outputPath);
            context.AddCode($"{FileName}.gen.cs", p.Result);
        }
    }

    [Generator]
    internal sealed class AnyToBoolAdaptersGenerator : AnyToAnyAdaptersGenerator
    {
        protected override string ToType => "bool";

        protected override string ToTypeName => "Bool";

        protected override string ReturnStatement => "result > 0";

        protected override string FileName => "AnyToBoolAdapters";
    }

    [Generator]
    internal sealed class AnyToNotBoolAdaptersGenerator : AnyToAnyAdaptersGenerator
    {
        protected override string ToType => "bool";

        protected override string ToTypeName => "NotBool";

        protected override string ToTypeNameLabel => "! Bool";

        protected override int Order => 1;

        protected override string ReturnStatement => "result <= 0";

        protected override string FileName => "AnyToNotBoolAdapters";
    }

    [Generator]
    internal sealed class AnyToFloatAdaptersGenerator : AnyToAnyAdaptersGenerator
    {
        protected override string ToType => "float";

        protected override string ToTypeName => "Float";

        protected override string ReturnStatement => "(float)result";

        protected override string FileName => "AnyToFloatAdapters";
    }

    [Generator]
    internal sealed class AnyToIntAdaptersGenerator : AnyToAnyAdaptersGenerator
    {
        protected override string ToType => "int";

        protected override string ToTypeName => "Int";

        protected override string ReturnStatement => "(int)result";

        protected override string FileName => "AnyToIntAdapters";
    }

    [Generator]
    internal sealed class AnyToStringAdaptersGenerator : AnyToAnyAdaptersGenerator
    {
        protected override string ToType => "string";

        protected override string ToTypeName => "String";

        protected override string ReturnStatement => "result.ToString()";

        protected override string FileName => "AnyToStringAdapters";
    }
}

#endif
